// Natural and floating-point numbers
define Nat = Nat;
assume cNat0: Nat;
assume opNatPlus:  (Nat, Nat) -> Nat;
assume opNatMinus: (Nat, Nat) -> Nat;

assume Float: *;
assume opFloatPlus:  (Float, Float) -> Float;
assume opFloatMinus: (Float, Float) -> Float;
assume opFloatMult:  (Float, Float) -> Float;
assume opFloatDiv:   (Float, Float) -> Float;
assume cFloatZero: Float;

// if <type> <condition> <then> <else> := (<condition> ? <then> : <else>): <type>
assume ifcond: pi t:*. Nat -> sigma(t, t) ->  t;

// Arrays
assume ArrT: pi_:(Nat, Nat -> *). *;
assume ArrCreate: pi type: (Nat, Nat -> *). (pi i: Nat. type[1] i) -> ArrT type;
assume ArrGet: pi type: (Nat, Nat -> *). ArrT type -> pi i:Nat. type[1] i;
define UArrT = lambda lt: (Nat, *). ArrT (lt[0], lambda _:Nat. lt[1]);

define MatrixType = lambda n:Nat. lambda m:Nat. UArrT (n, UArrT (m, Float));

assume reduce: pi t:*. pi op: ((t, t) -> t). pi startval:t. pi len:Nat. pi values:(Nat -> t). t;
define sum = reduce Float opFloatPlus cFloatZero;


// --- LU Decomposition ---

define LType = λn:Nat. ArrT (n, λi:Nat. UArrT (i, Float));
define UType = λn:Nat. ArrT (n, λi:Nat. UArrT (opNatMinus(n,i), Float));
define LTypePair = λn:Nat. (n, λi:Nat. UArrT (i, Float));
define UTypePair = λn:Nat. (n, λi:Nat. UArrT (opNatMinus(n,i), Float));

define AGet = lambda n:Nat. lambda A:MatrixType n n. lambda i:Nat. lambda j:Nat.
    ArrGet (n, lambda _:Nat. Float) (ArrGet (n, lambda _:Nat. UArrT (n, Float)) A i) j;
define UGet = lambda n:Nat. lambda U:UType n. lambda i:Nat. lambda j:Nat.
    ArrGet (opNatMinus(n,i), lambda _:Nat. Float) (ArrGet (UTypePair n) U i) j;
define LGet = lambda n:Nat. lambda L:LType n. lambda i:Nat. lambda j:Nat.
    ArrGet (i, lambda _:Nat. Float) (ArrGet (LTypePair n) L i) j;

define LUD = lambda n:Nat. lambda A:MatrixType n n. let
		define U = ArrCreate (UTypePair n) (lambda i:Nat.
			ArrCreate (opNatMinus(n,i), lambda _:Nat. Float) (lambda rec (j:Nat): Float.
			    ifcond Float i (
			        opFloatMinus (
			            AGet n A i (opNatPlus (i,j)),
			            sum i (lambda k:Nat. opFloatMult (LGet n L i k, UGet n U k (opNatMinus (opNatPlus(i, j), k))))
			        ),
			        AGet n A i j
			    )
			)
		);
		define L = ArrCreate (LTypePair n) (lambda i:Nat.
			ArrCreate (i, lambda _:Nat. Float) (lambda rec (j:Nat): Float.
				opFloatDiv (ifcond Float j (
			        opFloatMinus (
			            AGet n A i j,
			            sum j (lambda k:Nat. opFloatMult (LGet n L i k, UGet n U k (opNatMinus (j, k))))
			        ),
			        AGet n A i j
			    ), UGet n U j cNat0)
			)
		);
	in (L, U) end;

/*
LUD: Πn:Nat. MatrixType n n -> (LType n, UType n)
LUD = λn:Nat. λA: (MatrixType n n). let
	U = UType.ArrCreate (λi:Nat. (UArrT (n-i) Float).ArrCreate (λj: Nat.
		if i == 0 then A[i][j]
		else A[i][i+j] - sum i (λk:Nat. L[i][k] * U[k][i+j-k])
	))
	L = LType.ArrCreate (λi:Nat. (UArrT i Float).ArrCreate (λj: Nat.
		if j == 0 then A[i][j] / U[j][0]
		else ( A[i][j] - sum j (λk:Nat. L[i][k] * U[k][j-k]) ) / U[j][0]
	))
in
	(L, U)
end
*/
