Lambda Calculus Frontend
========================

This project provides a Python 2 frontend to CoC lambda expressions. 

Features
--------
- Read lambda expressions from a simple text format
- Convert them to C++ code, that generates the lambda expressions in CoC
- A (partial) Python implementation of CoC's type-checking process
- Constraint checking on natural numbers. 
This analysis can guarantee (for example) that an array access is never out of bounds.


Setup
-----
### Python setup
This project requires Python 2 and several modules. Installing is simple using `pip`. 
You can install the needed modules globally, or in a [virtualenv](http://docs.python-guide.org/en/latest/dev/virtualenvs/):
```
pip install pypeg2 islpy
```

### (optional) compile islpy
To speed up constraint checking, you can build my [extended version of `islpy`](https://github.com/MarkusBauer/islpy). 
You get the best results using Clang+LTO, but GCC will also work. 

- Checkout the extended `islpy`
- Build the extension. Use one of
  - `./clang-build.sh` for Clang+LTO
  - `python configure.py --cxxflags "-O3" --ldflags "-O3" && python setup.py build` for GCC (the original islpy library does not even apply compiler optimization)
- Install the compiled extension, or just symlink it: `ln -s <islpy-root>/build/lib.<???>/islpy <frontend-root>/islpy`
- If it worked, the frontend will greet you with `[islpy] Native extension present`. 


Basics
------
Lambda expressions are given as _Assumptions_ and _Definitions_. 
Assumptions are declared using their type. Example:

```
assume opNatPlus: (Nat,Nat)->Nat;        // Assume this function exists
define inc = λ x:Nat. opNatPlus (x,1);   // Define using previous assumption
define two = inc 1;
```

You can run the example script over this input:
`python frontend.py <input.lbl>`

To see the API of this project, look into [frontend.py](frontend.py). 


Lambda files
------------
Lambda files have the extension `.lbl` and must be encoded as UTF-8. 
Currently, there is no specification for lambda files. 
Just refer to the given examples, they use all features (including all possible annotations).
You can always write `lambda, pi, sigma` instead of `λ, Π, Σ`.
 
- [stdlib.lbl](programs/stdlib.lbl),  some basic assumptions
- [arrays.lbl](programs/arrays.lbl),  a formalization of arrays
- [matrixmultiplication.lbl](programs/matrixmultiplication.lbl),  a simple program


Constraint checking
-------------------
Constraint checking is based on the isl library. It is [explained here](constraint_checking.md).



Code Structure
--------------
The important code files are:

- [frontend.py](frontend.py) - Main interface for the important methods
- [lambdaparser.py](lambdaparser.py) can load programs and create a parse tree
- [ast.py](ast.py) contains an AST representation of expressions, similar to the CoC one (including type checking and constraint generation)
- [checker.py](checker.py) manages the [constraint checking](constraint_checking.md) process
- [predefined_functions.py](predefined_functions.py) handle special, pre-defined ast entities (such as Nat constants and conditionals)
- [tests/](tests/) contains unit tests for the important parts of this project

The important classes/methods are:
 
- Program texts are `unicode` strings (or filenames, if you want to use `#include`)
- Parsed programs are represented as tree of `lambdaparser.ParserAstNode`. The root is a `lambdaparser.Program` instance.
- Parse trees can be used to generate C++ code: `lambdaparser.ParserAstNode.to_cpp()`
- The AST representation is a tree of `ast.AstNode`. It is generated by `lambdaparser.ParserAstNode.to_ast()`.
- The type of an ast expression is derived using `ast.AstNode.get_type()`. 
- Constraints are a tuple `(vars, accepted, possible)`, where `vars` is a nested list and `accepted/possible` are `islpy.Set` or `islpy.BasicSet`.
- Constraints can be generated by `ast.AstNode.get_constraints()`.
- Constraints are checked using `checker.check_definition(<astnode>)`, which returns a `checker.ConstraintCheckResult`.

